(globalThis.webpackChunk_wp_playground_playground_block=globalThis.webpackChunk_wp_playground_playground_block||[]).push([[449],{449:(e,n,t)=>{(e=>{"use strict";var n,t=Object.defineProperty,s=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,o=(e,n,t)=>new Promise(((s,r)=>{var i=e=>{try{l(t.next(e))}catch(e){r(e)}},o=e=>{try{l(t.throw(e))}catch(e){r(e)}},l=e=>e.done?s(e.value):Promise.resolve(e.value).then(i,o);l((t=t.apply(e,n)).next())})),l={};function a(e){let n=e=>{if(null===e)t.write8(0);else if("boolean"==typeof e)t.write8(1),t.write8(+e);else if("number"==typeof e)t.write8(2),t.write32(0|e);else if("string"==typeof e)t.write8(3),t.write(c(e));else if(e instanceof Uint8Array)t.write8(4),t.write(e);else if(e instanceof Array){t.write8(5),t.write32(e.length);for(let t of e)n(t)}else{let s=Object.keys(e);t.write8(6),t.write32(s.length);for(let r of s)t.write(c(r)),n(e[r])}},t=new d;return t.write32(0),t.write32(e.id<<1|+!e.isRequest),n(e.value),p(t.buf,t.len-4,0),t.buf.subarray(0,t.len)}((e,n)=>{for(var s in n)t(e,s,{get:n[s],enumerable:!0})})(l,{analyzeMetafile:()=>oe,analyzeMetafileSync:()=>ue,build:()=>te,buildSync:()=>le,context:()=>se,default:()=>me,formatMessages:()=>ie,formatMessagesSync:()=>ce,initialize:()=>he,stop:()=>fe,transform:()=>re,transformSync:()=>ae,version:()=>ne}),e.exports=(n=l,((e,n,o,l)=>{if(n&&"object"==typeof n||"function"==typeof n)for(let o of r(n))i.call(e,o)||undefined===o||t(e,o,{get:()=>n[o],enumerable:!(l=s(n,o))||l.enumerable});return e})(t({},"__esModule",{value:!0}),n));var c,u,f,d=class{constructor(e=new Uint8Array(1024)){this.buf=e,this.len=0,this.ptr=0}_write(e){if(this.len+e>this.buf.length){let n=new Uint8Array(2*(this.len+e));n.set(this.buf),this.buf=n}return this.len+=e,this.len-e}write8(e){let n=this._write(1);this.buf[n]=e}write32(e){let n=this._write(4);p(this.buf,e,n)}write(e){let n=this._write(4+e.length);p(this.buf,e.length,n),this.buf.set(e,n+4)}_read(e){if(this.ptr+e>this.buf.length)throw new Error("Invalid packet");return this.ptr+=e,this.ptr-e}read8(){return this.buf[this._read(1)]}read32(){return h(this.buf,this._read(4))}read(){let e=this.read32(),n=new Uint8Array(e),t=this._read(n.length);return n.set(this.buf.subarray(t,t+e)),n}};if("undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder){let e=new TextEncoder,n=new TextDecoder;c=n=>e.encode(n),u=e=>n.decode(e),f='new TextEncoder().encode("")'}else{if("undefined"==typeof Buffer)throw new Error("No UTF-8 codec found");c=e=>Buffer.from(e),u=e=>{let{buffer:n,byteOffset:t,byteLength:s}=e;return Buffer.from(n,t,s).toString()},f='Buffer.from("")'}if(!(c("")instanceof Uint8Array))throw new Error(`Invariant violation: "${f} instanceof Uint8Array" is incorrectly false\n\nThis indicates that your JavaScript environment is broken. You cannot use\nesbuild in this environment because esbuild relies on this invariant. This\nis not a problem with esbuild. You need to fix your environment instead.\n`);function h(e,n){return e[n++]|e[n++]<<8|e[n++]<<16|e[n++]<<24}function p(e,n,t){e[t++]=n,e[t++]=n>>8,e[t++]=n>>16,e[t++]=n>>24}var m=JSON.stringify,g="warning",y="silent";function w(e){if(F(e,"target"),e.indexOf(",")>=0)throw new Error(`Invalid target: ${e}`);return e}var b=()=>null,v=e=>"boolean"==typeof e?null:"a boolean",x=e=>"string"==typeof e?null:"a string",k=e=>e instanceof RegExp?null:"a RegExp object",_=e=>"number"==typeof e&&e===(0|e)?null:"an integer",E=e=>"function"==typeof e?null:"a function",T=e=>Array.isArray(e)?null:"an array",$=e=>"object"!=typeof e||null===e||Array.isArray(e)?"an object":null,j=e=>"object"==typeof e&&null!==e?null:"an array or an object",S=e=>e instanceof WebAssembly.Module?null:"a WebAssembly.Module",P=e=>"object"!=typeof e||Array.isArray(e)?"an object or null":null,O=e=>"string"==typeof e||"boolean"==typeof e?null:"a string or a boolean",C=e=>"string"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)?null:"a string or an object",I=e=>"string"==typeof e||Array.isArray(e)?null:"a string or an array",U=e=>"string"==typeof e||e instanceof Uint8Array?null:"a string or a Uint8Array",R=e=>"string"==typeof e||e instanceof URL?null:"a string or a URL";function A(e,n,t,s){let r=e[t];if(n[t+""]=!0,void 0===r)return;let i=s(r);if(null!==i)throw new Error(`${m(t)} must be ${i}`);return r}function D(e,n,t){for(let s in e)if(!(s in n))throw new Error(`Invalid option ${t}: ${m(s)}`)}function N(e){let n;if(void 0!==e){n=Object.create(null);for(let t in e){let s=e[t];if("string"!=typeof s&&!1!==s)throw new Error(`Expected ${m(t)} in mangle cache to map to either a string or false`);n[t]=s}}return n}function M(e,n,t,s,r){let i=A(n,t,"color",v),o=A(n,t,"logLevel",x),l=A(n,t,"logLimit",_);void 0!==i?e.push(`--color=${i}`):s&&e.push("--color=true"),e.push(`--log-level=${o||r}`),e.push(`--log-limit=${l||0}`)}function F(e,n,t){if("string"!=typeof e)throw new Error(`Expected value for ${n}${void 0!==t?" "+m(t):""} to be a string, got ${typeof e} instead`);return e}function V(e,n,t){let s=A(n,t,"legalComments",x),r=A(n,t,"sourceRoot",x),i=A(n,t,"sourcesContent",v),o=A(n,t,"target",I),l=A(n,t,"format",x),a=A(n,t,"globalName",x),c=A(n,t,"mangleProps",k),u=A(n,t,"reserveProps",k),f=A(n,t,"mangleQuoted",v),d=A(n,t,"minify",v),h=A(n,t,"minifySyntax",v),p=A(n,t,"minifyWhitespace",v),g=A(n,t,"minifyIdentifiers",v),y=A(n,t,"lineLimit",_),b=A(n,t,"drop",T),E=A(n,t,"dropLabels",T),j=A(n,t,"charset",x),S=A(n,t,"treeShaking",v),P=A(n,t,"ignoreAnnotations",v),O=A(n,t,"jsx",x),U=A(n,t,"jsxFactory",x),R=A(n,t,"jsxFragment",x),D=A(n,t,"jsxImportSource",x),N=A(n,t,"jsxDev",v),M=A(n,t,"jsxSideEffects",v),V=A(n,t,"define",$),W=A(n,t,"logOverride",$),L=A(n,t,"supported",$),B=A(n,t,"pure",T),G=A(n,t,"keepNames",v),q=A(n,t,"platform",x),z=A(n,t,"tsconfigRaw",C);if(s&&e.push(`--legal-comments=${s}`),void 0!==r&&e.push(`--source-root=${r}`),void 0!==i&&e.push(`--sources-content=${i}`),o&&(Array.isArray(o)?e.push(`--target=${Array.from(o).map(w).join(",")}`):e.push(`--target=${w(o)}`)),l&&e.push(`--format=${l}`),a&&e.push(`--global-name=${a}`),q&&e.push(`--platform=${q}`),z&&e.push(`--tsconfig-raw=${"string"==typeof z?z:JSON.stringify(z)}`),d&&e.push("--minify"),h&&e.push("--minify-syntax"),p&&e.push("--minify-whitespace"),g&&e.push("--minify-identifiers"),y&&e.push(`--line-limit=${y}`),j&&e.push(`--charset=${j}`),void 0!==S&&e.push(`--tree-shaking=${S}`),P&&e.push("--ignore-annotations"),b)for(let n of b)e.push(`--drop:${F(n,"drop")}`);if(E&&e.push(`--drop-labels=${Array.from(E).map((e=>F(e,"dropLabels"))).join(",")}`),c&&e.push(`--mangle-props=${c.source}`),u&&e.push(`--reserve-props=${u.source}`),void 0!==f&&e.push(`--mangle-quoted=${f}`),O&&e.push(`--jsx=${O}`),U&&e.push(`--jsx-factory=${U}`),R&&e.push(`--jsx-fragment=${R}`),D&&e.push(`--jsx-import-source=${D}`),N&&e.push("--jsx-dev"),M&&e.push("--jsx-side-effects"),V)for(let n in V){if(n.indexOf("=")>=0)throw new Error(`Invalid define: ${n}`);e.push(`--define:${n}=${F(V[n],"define",n)}`)}if(W)for(let n in W){if(n.indexOf("=")>=0)throw new Error(`Invalid log override: ${n}`);e.push(`--log-override:${n}=${F(W[n],"log override",n)}`)}if(L)for(let n in L){if(n.indexOf("=")>=0)throw new Error(`Invalid supported: ${n}`);const t=L[n];if("boolean"!=typeof t)throw new Error(`Expected value for supported ${m(n)} to be a boolean, got ${typeof t} instead`);e.push(`--supported:${n}=${t}`)}if(B)for(let n of B)e.push(`--pure:${F(n,"pure")}`);G&&e.push("--keep-names")}var W=(e,n,t,s,r,i,l,a,u)=>o(void 0,null,(function*(){let f=[],d=[],h={},p={},g=[],y=0,w=0,_=[],$=!1;a=[...a];for(let t of a){let i={};if("object"!=typeof t)throw new Error(`Plugin at index ${w} must be an object`);const o=A(t,i,"name",x);if("string"!=typeof o||""===o)throw new Error(`Plugin at index ${w} is missing a name`);try{let a=A(t,i,"setup",E);if("function"!=typeof a)throw new Error("Plugin is missing a setup function");D(t,i,`on plugin ${m(o)}`);let c={name:o,onStart:!1,onEnd:!1,onResolve:[],onLoad:[]};w++;let v=a({initialOptions:l,resolve:(t,r={})=>{if(!$)throw new Error('Cannot call "resolve" before plugin setup has completed');if("string"!=typeof t)throw new Error("The path to resolve must be a string");let i=Object.create(null),l=A(r,i,"pluginName",x),a=A(r,i,"importer",x),c=A(r,i,"namespace",x),f=A(r,i,"resolveDir",x),d=A(r,i,"kind",x),h=A(r,i,"pluginData",b);return D(r,i,"in resolve() call"),new Promise(((r,i)=>{const p={command:"resolve",path:t,key:e,pluginName:o};if(null!=l&&(p.pluginName=l),null!=a&&(p.importer=a),null!=c&&(p.namespace=c),null!=f&&(p.resolveDir=f),null==d)throw new Error('Must specify "kind" when calling "resolve"');p.kind=d,null!=h&&(p.pluginData=u.store(h)),n(s,p,((e,n)=>{null!==e?i(new Error(e)):r({errors:Y(n.errors,u),warnings:Y(n.warnings,u),path:n.path,external:n.external,sideEffects:n.sideEffects,namespace:n.namespace,suffix:n.suffix,pluginData:u.load(n.pluginData)})}))}))},onStart(e){let n=B(new Error('This error came from the "onStart" callback registered here:'),r,"onStart");f.push({name:o,callback:e,note:n}),c.onStart=!0},onEnd(e){let n=B(new Error('This error came from the "onEnd" callback registered here:'),r,"onEnd");d.push({name:o,callback:e,note:n}),c.onEnd=!0},onResolve(e,n){let t=B(new Error('This error came from the "onResolve" callback registered here:'),r,"onResolve"),s={},i=A(e,s,"filter",k),l=A(e,s,"namespace",x);if(D(e,s,`in onResolve() call for plugin ${m(o)}`),null==i)throw new Error("onResolve() call is missing a filter");let a=y++;h[a]={name:o,callback:n,note:t},c.onResolve.push({id:a,filter:i.source,namespace:l||""})},onLoad(e,n){let t=B(new Error('This error came from the "onLoad" callback registered here:'),r,"onLoad"),s={},i=A(e,s,"filter",k),l=A(e,s,"namespace",x);if(D(e,s,`in onLoad() call for plugin ${m(o)}`),null==i)throw new Error("onLoad() call is missing a filter");let a=y++;p[a]={name:o,callback:n,note:t},c.onLoad.push({id:a,filter:i.source,namespace:l||""})},onDispose(e){g.push(e)},esbuild:r.esbuild});v&&(yield v),_.push(c)}catch(e){return{ok:!1,error:e,pluginName:o}}}i["on-start"]=(e,n)=>o(void 0,null,(function*(){let n={errors:[],warnings:[]};yield Promise.all(f.map((e=>o(void 0,[e],(function*({name:e,callback:t,note:s}){try{let s=yield t();if(null!=s){if("object"!=typeof s)throw new Error(`Expected onStart() callback in plugin ${m(e)} to return an object`);let t={},r=A(s,t,"errors",T),i=A(s,t,"warnings",T);D(s,t,`from onStart() callback in plugin ${m(e)}`),null!=r&&n.errors.push(...H(r,"errors",u,e,void 0)),null!=i&&n.warnings.push(...H(i,"warnings",u,e,void 0))}}catch(t){n.errors.push(G(t,r,u,s&&s(),e))}}))))),t(e,n)})),i["on-resolve"]=(e,n)=>o(void 0,null,(function*(){let s,i,o={},l="";for(let e of n.ids)try{({name:l,callback:s,note:i}=h[e]);let t=yield s({path:n.path,importer:n.importer,namespace:n.namespace,resolveDir:n.resolveDir,kind:n.kind,pluginData:u.load(n.pluginData)});if(null!=t){if("object"!=typeof t)throw new Error(`Expected onResolve() callback in plugin ${m(l)} to return an object`);let n={},s=A(t,n,"pluginName",x),r=A(t,n,"path",x),i=A(t,n,"namespace",x),a=A(t,n,"suffix",x),c=A(t,n,"external",v),f=A(t,n,"sideEffects",v),d=A(t,n,"pluginData",b),h=A(t,n,"errors",T),p=A(t,n,"warnings",T),g=A(t,n,"watchFiles",T),y=A(t,n,"watchDirs",T);D(t,n,`from onResolve() callback in plugin ${m(l)}`),o.id=e,null!=s&&(o.pluginName=s),null!=r&&(o.path=r),null!=i&&(o.namespace=i),null!=a&&(o.suffix=a),null!=c&&(o.external=c),null!=f&&(o.sideEffects=f),null!=d&&(o.pluginData=u.store(d)),null!=h&&(o.errors=H(h,"errors",u,l,void 0)),null!=p&&(o.warnings=H(p,"warnings",u,l,void 0)),null!=g&&(o.watchFiles=X(g,"watchFiles")),null!=y&&(o.watchDirs=X(y,"watchDirs"));break}}catch(n){o={id:e,errors:[G(n,r,u,i&&i(),l)]};break}t(e,o)})),i["on-load"]=(e,n)=>o(void 0,null,(function*(){let s,i,o={},l="";for(let e of n.ids)try{({name:l,callback:s,note:i}=p[e]);let t=yield s({path:n.path,namespace:n.namespace,suffix:n.suffix,pluginData:u.load(n.pluginData),with:n.with});if(null!=t){if("object"!=typeof t)throw new Error(`Expected onLoad() callback in plugin ${m(l)} to return an object`);let n={},s=A(t,n,"pluginName",x),r=A(t,n,"contents",U),i=A(t,n,"resolveDir",x),a=A(t,n,"pluginData",b),f=A(t,n,"loader",x),d=A(t,n,"errors",T),h=A(t,n,"warnings",T),p=A(t,n,"watchFiles",T),g=A(t,n,"watchDirs",T);D(t,n,`from onLoad() callback in plugin ${m(l)}`),o.id=e,null!=s&&(o.pluginName=s),r instanceof Uint8Array?o.contents=r:null!=r&&(o.contents=c(r)),null!=i&&(o.resolveDir=i),null!=a&&(o.pluginData=u.store(a)),null!=f&&(o.loader=f),null!=d&&(o.errors=H(d,"errors",u,l,void 0)),null!=h&&(o.warnings=H(h,"warnings",u,l,void 0)),null!=p&&(o.watchFiles=X(p,"watchFiles")),null!=g&&(o.watchDirs=X(g,"watchDirs"));break}}catch(n){o={id:e,errors:[G(n,r,u,i&&i(),l)]};break}t(e,o)}));let j=(e,n)=>n([],[]);return d.length>0&&(j=(e,n)=>{o(void 0,null,(function*(){const t=[],s=[];for(const{name:n,callback:i,note:o}of d){let l,a;try{const t=yield i(e);if(null!=t){if("object"!=typeof t)throw new Error(`Expected onEnd() callback in plugin ${m(n)} to return an object`);let e={},s=A(t,e,"errors",T),r=A(t,e,"warnings",T);D(t,e,`from onEnd() callback in plugin ${m(n)}`),null!=s&&(l=H(s,"errors",u,n,void 0)),null!=r&&(a=H(r,"warnings",u,n,void 0))}}catch(e){l=[G(e,r,u,o&&o(),n)]}if(l){t.push(...l);try{e.errors.push(...l)}catch(e){}}if(a){s.push(...a);try{e.warnings.push(...a)}catch(e){}}}n(t,s)}))}),$=!0,{ok:!0,requestPlugins:_,runOnEndCallbacks:j,scheduleOnDisposeCallbacks:()=>{for(const e of g)setTimeout((()=>e()),0)}}}));function L(){const e=new Map;let n=0;return{load:n=>e.get(n),store(t){if(void 0===t)return-1;const s=n++;return e.set(s,t),s}}}function B(e,n,t){let s,r=!1;return()=>{if(r)return s;r=!0;try{let r=(e.stack+"").split("\n");r.splice(1,1);let i=q(n,r,t);if(i)return s={text:e.message,location:i},s}catch(e){}}}function G(e,n,t,s,r){let i="Internal error",o=null;try{i=(e&&e.message||e)+""}catch(e){}try{o=q(n,(e.stack+"").split("\n"),"")}catch(e){}return{id:"",pluginName:r,text:i,location:o,notes:s?[s]:[],detail:t?t.store(e):-1}}function q(e,n,t){let s="    at ";if(e.readFileSync&&!n[0].startsWith(s)&&n[1].startsWith(s))for(let r=1;r<n.length;r++){let i=n[r];if(i.startsWith(s))for(i=i.slice(7);;){let s=/^(?:new |async )?\S+ \((.*)\)$/.exec(i);if(s)i=s[1];else{if(s=/^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(i),!s){if(s=/^(\S+):(\d+):(\d+)$/.exec(i),s){let r;try{r=e.readFileSync(s[1],"utf8")}catch(e){break}let i=r.split(/\r\n|\r|\n|\u2028|\u2029/)[+s[2]-1]||"",o=+s[3]-1,l=i.slice(o,o+t.length)===t?t.length:0;return{file:s[1],namespace:"file",line:+s[2],column:c(i.slice(0,o)).length,length:c(i.slice(o,o+l)).length,lineText:i+"\n"+n.slice(1).join("\n"),suggestion:""}}break}i=s[1]}}}return null}function z(e,n,t){e+=n.length<1?"":` with ${n.length} error${n.length<2?"":"s"}:`+n.slice(0,6).map(((e,n)=>{if(5===n)return"\n...";if(!e.location)return`\nerror: ${e.text}`;let{file:t,line:s,column:r}=e.location;return`\n${t}:${s}:${r}: ERROR: ${e.pluginName?`[plugin: ${e.pluginName}] `:""}${e.text}`})).join("");let s=new Error(e);for(const[e,r]of[["errors",n],["warnings",t]])Object.defineProperty(s,e,{configurable:!0,enumerable:!0,get:()=>r,set:n=>Object.defineProperty(s,e,{configurable:!0,enumerable:!0,value:n})});return s}function Y(e,n){for(const t of e)t.detail=n.load(t.detail);return e}function J(e,n,t){if(null==e)return null;let s={},r=A(e,s,"file",x),i=A(e,s,"namespace",x),o=A(e,s,"line",_),l=A(e,s,"column",_),a=A(e,s,"length",_),c=A(e,s,"lineText",x),u=A(e,s,"suggestion",x);if(D(e,s,n),c){const e=c.slice(0,(l&&l>0?l:0)+(a&&a>0?a:0)+(t&&t>0?t:80));/[\x7F-\uFFFF]/.test(e)||/\n/.test(c)||(c=e)}return{file:r||"",namespace:i||"",line:o||0,column:l||0,length:a||0,lineText:c||"",suggestion:u||""}}function H(e,n,t,s,r){let i=[],o=0;for(const l of e){let e={},a=A(l,e,"id",x),c=A(l,e,"pluginName",x),u=A(l,e,"text",x),f=A(l,e,"location",P),d=A(l,e,"notes",T),h=A(l,e,"detail",b),p=`in element ${o} of "${n}"`;D(l,e,p);let m=[];if(d)for(const e of d){let n={},t=A(e,n,"text",x),s=A(e,n,"location",P);D(e,n,p),m.push({text:t||"",location:J(s,p,r)})}i.push({id:a||"",pluginName:c||s,text:u||"",location:J(f,p,r),notes:m,detail:t?t.store(h):-1}),o++}return i}function X(e,n){const t=[];for(const s of e){if("string"!=typeof s)throw new Error(`${m(n)} must be an array of strings`);t.push(s)}return t}function Q({path:e,contents:n,hash:t}){let s=null;return{path:e,contents:n,hash:t,get text(){const e=this.contents;return null!==s&&e===n||(n=e,s=u(e)),s}}}var K,Z,ee,ne="0.21.3",te=e=>de().build(e),se=e=>de().context(e),re=(e,n)=>de().transform(e,n),ie=(e,n)=>de().formatMessages(e,n),oe=(e,n)=>de().analyzeMetafile(e,n),le=()=>{throw new Error('The "buildSync" API only works in node')},ae=()=>{throw new Error('The "transformSync" API only works in node')},ce=()=>{throw new Error('The "formatMessagesSync" API only works in node')},ue=()=>{throw new Error('The "analyzeMetafileSync" API only works in node')},fe=()=>(Z&&Z(),Promise.resolve()),de=()=>{if(ee)return ee;if(K)throw new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this');throw new Error('You need to call "initialize" before calling this')},he=e=>{e=function(e){let n=Object.create(null),t=A(e,n,"wasmURL",R),s=A(e,n,"wasmModule",S),r=A(e,n,"worker",v);return D(e,n,"in initialize() call"),{wasmURL:t,wasmModule:s,worker:r}}(e||{});let n=e.wasmURL,t=e.wasmModule,s=!1!==e.worker;if(!n&&!t)throw new Error('Must provide either the "wasmURL" option or the "wasmModule" option');if(K)throw new Error('Cannot call "initialize" more than once');return(K=pe(n||"",t,s)).catch((()=>{K=void 0})),K},pe=(e,n,t)=>o(void 0,null,(function*(){let s,r,i;if(t){let e=new Blob(['onmessage=((postMessage) => {\n      // Copyright 2018 The Go Authors. All rights reserved.\n      // Use of this source code is governed by a BSD-style\n      // license that can be found in the LICENSE file.\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve, reject) => {\n          var fulfilled = (value) => {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value) => {\n            try {\n              step(generator.throw(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      let onmessage;\n      let globalThis = {};\n      for (let o = self; o; o = Object.getPrototypeOf(o))\n        for (let k of Object.getOwnPropertyNames(o))\n          if (!(k in globalThis))\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\n      "use strict";\n      (() => {\n        const enosys = () => {\n          const err = new Error("not implemented");\n          err.code = "ENOSYS";\n          return err;\n        };\n        if (!globalThis.fs) {\n          let outputBuf = "";\n          globalThis.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\n            // unused\n            writeSync(fd, buf) {\n              outputBuf += decoder.decode(buf);\n              const nl = outputBuf.lastIndexOf("\\n");\n              if (nl != -1) {\n                console.log(outputBuf.substring(0, nl));\n                outputBuf = outputBuf.substring(nl + 1);\n              }\n              return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n              if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n              }\n              const n = this.writeSync(fd, buf);\n              callback(null, n);\n            },\n            chmod(path, mode, callback) {\n              callback(enosys());\n            },\n            chown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            close(fd, callback) {\n              callback(enosys());\n            },\n            fchmod(fd, mode, callback) {\n              callback(enosys());\n            },\n            fchown(fd, uid, gid, callback) {\n              callback(enosys());\n            },\n            fstat(fd, callback) {\n              callback(enosys());\n            },\n            fsync(fd, callback) {\n              callback(null);\n            },\n            ftruncate(fd, length, callback) {\n              callback(enosys());\n            },\n            lchown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            link(path, link, callback) {\n              callback(enosys());\n            },\n            lstat(path, callback) {\n              callback(enosys());\n            },\n            mkdir(path, perm, callback) {\n              callback(enosys());\n            },\n            open(path, flags, mode, callback) {\n              callback(enosys());\n            },\n            read(fd, buffer, offset, length, position, callback) {\n              callback(enosys());\n            },\n            readdir(path, callback) {\n              callback(enosys());\n            },\n            readlink(path, callback) {\n              callback(enosys());\n            },\n            rename(from, to, callback) {\n              callback(enosys());\n            },\n            rmdir(path, callback) {\n              callback(enosys());\n            },\n            stat(path, callback) {\n              callback(enosys());\n            },\n            symlink(path, link, callback) {\n              callback(enosys());\n            },\n            truncate(path, length, callback) {\n              callback(enosys());\n            },\n            unlink(path, callback) {\n              callback(enosys());\n            },\n            utimes(path, atime, mtime, callback) {\n              callback(enosys());\n            }\n          };\n        }\n        if (!globalThis.process) {\n          globalThis.process = {\n            getuid() {\n              return -1;\n            },\n            getgid() {\n              return -1;\n            },\n            geteuid() {\n              return -1;\n            },\n            getegid() {\n              return -1;\n            },\n            getgroups() {\n              throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            umask() {\n              throw enosys();\n            },\n            cwd() {\n              throw enosys();\n            },\n            chdir() {\n              throw enosys();\n            }\n          };\n        }\n        if (!globalThis.crypto) {\n          throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");\n        }\n        if (!globalThis.performance) {\n          throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");\n        }\n        if (!globalThis.TextEncoder) {\n          throw new Error("globalThis.TextEncoder is not available, polyfill required");\n        }\n        if (!globalThis.TextDecoder) {\n          throw new Error("globalThis.TextDecoder is not available, polyfill required");\n        }\n        const encoder = new TextEncoder("utf-8");\n        const decoder = new TextDecoder("utf-8");\n        globalThis.Go = class {\n          constructor() {\n            this.argv = ["js"];\n            this.env = {};\n            this.exit = (code) => {\n              if (code !== 0) {\n                console.warn("exit code:", code);\n              }\n            };\n            this._exitPromise = new Promise((resolve) => {\n              this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\n            this._nextCallbackTimeoutID = 1;\n            const setInt64 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            const getInt64 = (addr) => {\n              const low = this.mem.getUint32(addr + 0, true);\n              const high = this.mem.getInt32(addr + 4, true);\n              return low + high * 4294967296;\n            };\n            const loadValue = (addr) => {\n              const f = this.mem.getFloat64(addr, true);\n              if (f === 0) {\n                return void 0;\n              }\n              if (!isNaN(f)) {\n                return f;\n              }\n              const id = this.mem.getUint32(addr, true);\n              return this._values[id];\n            };\n            const storeValue = (addr, v) => {\n              const nanHead = 2146959360;\n              if (typeof v === "number" && v !== 0) {\n                if (isNaN(v)) {\n                  this.mem.setUint32(addr + 4, nanHead, true);\n                  this.mem.setUint32(addr, 0, true);\n                  return;\n                }\n                this.mem.setFloat64(addr, v, true);\n                return;\n              }\n              if (v === void 0) {\n                this.mem.setFloat64(addr, 0, true);\n                return;\n              }\n              let id = this._ids.get(v);\n              if (id === void 0) {\n                id = this._idPool.pop();\n                if (id === void 0) {\n                  id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n              }\n              this._goRefCounts[id]++;\n              let typeFlag = 0;\n              switch (typeof v) {\n                case "object":\n                  if (v !== null) {\n                    typeFlag = 1;\n                  }\n                  break;\n                case "string":\n                  typeFlag = 2;\n                  break;\n                case "symbol":\n                  typeFlag = 3;\n                  break;\n                case "function":\n                  typeFlag = 4;\n                  break;\n              }\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n              this.mem.setUint32(addr, id, true);\n            };\n            const loadSlice = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            const loadSliceOfValues = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              const a = new Array(len);\n              for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n              }\n              return a;\n            };\n            const loadString = (addr) => {\n              const saddr = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n              go: {\n                // Go\'s SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                // This changes the SP, thus we have to update the SP used by the imported function.\n                // func wasmExit(code int32)\n                "runtime.wasmExit": (sp) => {\n                  sp >>>= 0;\n                  const code = this.mem.getInt32(sp + 8, true);\n                  this.exited = true;\n                  delete this._inst;\n                  delete this._values;\n                  delete this._goRefCounts;\n                  delete this._ids;\n                  delete this._idPool;\n                  this.exit(code);\n                },\n                // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                "runtime.wasmWrite": (sp) => {\n                  sp >>>= 0;\n                  const fd = getInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                // func resetMemoryDataView()\n                "runtime.resetMemoryDataView": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                // func nanotime1() int64\n                "runtime.nanotime1": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                // func walltime() (sec int64, nsec int32)\n                "runtime.walltime": (sp) => {\n                  sp >>>= 0;\n                  const msec = (/* @__PURE__ */ new Date()).getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                // func scheduleTimeoutEvent(delay int64) int32\n                "runtime.scheduleTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(\n                    () => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn("scheduleTimeoutEvent: missed timeout event");\n                        this._resume();\n                      }\n                    },\n                    getInt64(sp + 8) + 1\n                    // setTimeout has been seen to fire up to 1 millisecond early\n                  ));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                // func clearTimeoutEvent(id int32)\n                "runtime.clearTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                // func getRandomData(r []byte)\n                "runtime.getRandomData": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                // func finalizeRef(v ref)\n                "syscall/js.finalizeRef": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                // func stringVal(value string) ref\n                "syscall/js.stringVal": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                // func valueGet(v ref, p string) ref\n                "syscall/js.valueGet": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                // func valueSet(v ref, p string, x ref)\n                "syscall/js.valueSet": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                // func valueDelete(v ref, p string)\n                "syscall/js.valueDelete": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                // func valueIndex(v ref, i int) ref\n                "syscall/js.valueIndex": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                // valueSetIndex(v ref, i int, x ref)\n                "syscall/js.valueSetIndex": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                // func valueCall(v ref, m string, args []ref) (ref, bool)\n                "syscall/js.valueCall": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                // func valueInvoke(v ref, args []ref) (ref, bool)\n                "syscall/js.valueInvoke": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                // func valueNew(v ref, args []ref) (ref, bool)\n                "syscall/js.valueNew": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                // func valueLength(v ref) int\n                "syscall/js.valueLength": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                // valuePrepareString(v ref) (ref, int)\n                "syscall/js.valuePrepareString": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                // valueLoadString(v ref, b []byte)\n                "syscall/js.valueLoadString": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                // func valueInstanceOf(v ref, t ref) bool\n                "syscall/js.valueInstanceOf": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                "syscall/js.copyBytesToGo": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                "syscall/js.copyBytesToJS": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "debug": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          run(instance) {\n            return __async(this, null, function* () {\n              if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error("Go.run: WebAssembly.Instance expected");\n              }\n              this._inst = instance;\n              this.mem = new DataView(this._inst.exports.mem.buffer);\n              this._values = [\n                // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n              ];\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\n              this._ids = /* @__PURE__ */ new Map([\n                // mapping from JS values to reference ids\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6]\n              ]);\n              this._idPool = [];\n              this.exited = false;\n              let offset = 4096;\n              const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + "\\0");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                  offset += 8 - offset % 8;\n                }\n                return ptr;\n              };\n              const argc = this.argv.length;\n              const argvPtrs = [];\n              this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n              });\n              argvPtrs.push(0);\n              const keys = Object.keys(this.env).sort();\n              keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n              });\n              argvPtrs.push(0);\n              const argv = offset;\n              argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n              });\n              const wasmMinDataAddr = 4096 + 8192;\n              if (offset >= wasmMinDataAddr) {\n                throw new Error("total length of command line and environment variables exceeds limit");\n              }\n              this._inst.exports.run(argc, argv);\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n              yield this._exitPromise;\n            });\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error("Go program has already exited");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = "";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split("\\n");\n            if (parts.length > 1) console.log(parts.slice(0, -1).join("\\n"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error("Bad write");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin) resumeStdin();\n          }\n          return go;\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error("Bad read");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = ["", `--service=${"0.21.3"}`];\n        tryToInstantiateModule(wasm, go).then(\n          (instance) => {\n            postMessage(null);\n            go.run(instance);\n          },\n          (error) => {\n            postMessage(error);\n          }\n        );\n        return go;\n      };\n      function tryToInstantiateModule(wasm, go) {\n        return __async(this, null, function* () {\n          if (wasm instanceof WebAssembly.Module) {\n            return WebAssembly.instantiate(wasm, go.importObject);\n          }\n          const res = yield fetch(wasm);\n          if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasm)}`);\n          if ("instantiateStreaming" in WebAssembly && /^application\\/wasm($|;)/i.test(res.headers.get("Content-Type") || "")) {\n            const result2 = yield WebAssembly.instantiateStreaming(res, go.importObject);\n            return result2.instance;\n          }\n          const bytes = yield res.arrayBuffer();\n          const result = yield WebAssembly.instantiate(bytes, go.importObject);\n          return result.instance;\n        });\n      }\n      return (m) => onmessage(m);\n    })(postMessage)'],{type:"text/javascript"});s=new Worker(URL.createObjectURL(e))}else{let e,n=(e=>{var n=(e,n,t)=>new Promise(((s,r)=>{var i=e=>{try{l(t.next(e))}catch(e){r(e)}},o=e=>{try{l(t.throw(e))}catch(e){r(e)}},l=e=>e.done?s(e.value):Promise.resolve(e.value).then(i,o);l((t=t.apply(e,n)).next())}));let t,s={};for(let e=self;e;e=Object.getPrototypeOf(e))for(let n of Object.getOwnPropertyNames(e))n in s||Object.defineProperty(s,n,{get:()=>self[n]});return(()=>{const e=()=>{const e=new Error("not implemented");return e.code="ENOSYS",e};if(!s.fs){let n="";s.fs={constants:{O_WRONLY:-1,O_RDWR:-1,O_CREAT:-1,O_TRUNC:-1,O_APPEND:-1,O_EXCL:-1},writeSync(e,t){n+=r.decode(t);const s=n.lastIndexOf("\n");return-1!=s&&(console.log(n.substring(0,s)),n=n.substring(s+1)),t.length},write(n,t,s,r,i,o){0===s&&r===t.length&&null===i?o(null,this.writeSync(n,t)):o(e())},chmod(n,t,s){s(e())},chown(n,t,s,r){r(e())},close(n,t){t(e())},fchmod(n,t,s){s(e())},fchown(n,t,s,r){r(e())},fstat(n,t){t(e())},fsync(e,n){n(null)},ftruncate(n,t,s){s(e())},lchown(n,t,s,r){r(e())},link(n,t,s){s(e())},lstat(n,t){t(e())},mkdir(n,t,s){s(e())},open(n,t,s,r){r(e())},read(n,t,s,r,i,o){o(e())},readdir(n,t){t(e())},readlink(n,t){t(e())},rename(n,t,s){s(e())},rmdir(n,t){t(e())},stat(n,t){t(e())},symlink(n,t,s){s(e())},truncate(n,t,s){s(e())},unlink(n,t){t(e())},utimes(n,t,s,r){r(e())}}}if(s.process||(s.process={getuid:()=>-1,getgid:()=>-1,geteuid:()=>-1,getegid:()=>-1,getgroups(){throw e()},pid:-1,ppid:-1,umask(){throw e()},cwd(){throw e()},chdir(){throw e()}}),!s.crypto)throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");if(!s.performance)throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");if(!s.TextEncoder)throw new Error("globalThis.TextEncoder is not available, polyfill required");if(!s.TextDecoder)throw new Error("globalThis.TextDecoder is not available, polyfill required");const t=new TextEncoder("utf-8"),r=new TextDecoder("utf-8");s.Go=class{constructor(){this.argv=["js"],this.env={},this.exit=e=>{0!==e&&console.warn("exit code:",e)},this._exitPromise=new Promise((e=>{this._resolveExitPromise=e})),this._pendingEvent=null,this._scheduledTimeouts=new Map,this._nextCallbackTimeoutID=1;const e=(e,n)=>{this.mem.setUint32(e+0,n,!0),this.mem.setUint32(e+4,Math.floor(n/4294967296),!0)},n=e=>this.mem.getUint32(e+0,!0)+4294967296*this.mem.getInt32(e+4,!0),i=e=>{const n=this.mem.getFloat64(e,!0);if(0===n)return;if(!isNaN(n))return n;const t=this.mem.getUint32(e,!0);return this._values[t]},o=(e,n)=>{const t=2146959360;if("number"==typeof n&&0!==n)return isNaN(n)?(this.mem.setUint32(e+4,t,!0),void this.mem.setUint32(e,0,!0)):void this.mem.setFloat64(e,n,!0);if(void 0===n)return void this.mem.setFloat64(e,0,!0);let s=this._ids.get(n);void 0===s&&(s=this._idPool.pop(),void 0===s&&(s=this._values.length),this._values[s]=n,this._goRefCounts[s]=0,this._ids.set(n,s)),this._goRefCounts[s]++;let r=0;switch(typeof n){case"object":null!==n&&(r=1);break;case"string":r=2;break;case"symbol":r=3;break;case"function":r=4}this.mem.setUint32(e+4,t|r,!0),this.mem.setUint32(e,s,!0)},l=e=>{const t=n(e+0),s=n(e+8);return new Uint8Array(this._inst.exports.mem.buffer,t,s)},a=e=>{const t=n(e+0),s=n(e+8),r=new Array(s);for(let e=0;e<s;e++)r[e]=i(t+8*e);return r},c=e=>{const t=n(e+0),s=n(e+8);return r.decode(new DataView(this._inst.exports.mem.buffer,t,s))},u=Date.now()-performance.now();this.importObject={go:{"runtime.wasmExit":e=>{e>>>=0;const n=this.mem.getInt32(e+8,!0);this.exited=!0,delete this._inst,delete this._values,delete this._goRefCounts,delete this._ids,delete this._idPool,this.exit(n)},"runtime.wasmWrite":e=>{const t=n(8+(e>>>=0)),r=n(e+16),i=this.mem.getInt32(e+24,!0);s.fs.writeSync(t,new Uint8Array(this._inst.exports.mem.buffer,r,i))},"runtime.resetMemoryDataView":e=>{this.mem=new DataView(this._inst.exports.mem.buffer)},"runtime.nanotime1":n=>{e(8+(n>>>=0),1e6*(u+performance.now()))},"runtime.walltime":n=>{n>>>=0;const t=(new Date).getTime();e(n+8,t/1e3),this.mem.setInt32(n+16,t%1e3*1e6,!0)},"runtime.scheduleTimeoutEvent":e=>{e>>>=0;const t=this._nextCallbackTimeoutID;this._nextCallbackTimeoutID++,this._scheduledTimeouts.set(t,setTimeout((()=>{for(this._resume();this._scheduledTimeouts.has(t);)console.warn("scheduleTimeoutEvent: missed timeout event"),this._resume()}),n(e+8)+1)),this.mem.setInt32(e+16,t,!0)},"runtime.clearTimeoutEvent":e=>{e>>>=0;const n=this.mem.getInt32(e+8,!0);clearTimeout(this._scheduledTimeouts.get(n)),this._scheduledTimeouts.delete(n)},"runtime.getRandomData":e=>{e>>>=0,crypto.getRandomValues(l(e+8))},"syscall/js.finalizeRef":e=>{e>>>=0;const n=this.mem.getUint32(e+8,!0);if(this._goRefCounts[n]--,0===this._goRefCounts[n]){const e=this._values[n];this._values[n]=null,this._ids.delete(e),this._idPool.push(n)}},"syscall/js.stringVal":e=>{o(24+(e>>>=0),c(e+8))},"syscall/js.valueGet":e=>{e>>>=0;const n=Reflect.get(i(e+8),c(e+16));e=this._inst.exports.getsp()>>>0,o(e+32,n)},"syscall/js.valueSet":e=>{e>>>=0,Reflect.set(i(e+8),c(e+16),i(e+32))},"syscall/js.valueDelete":e=>{e>>>=0,Reflect.deleteProperty(i(e+8),c(e+16))},"syscall/js.valueIndex":e=>{o(24+(e>>>=0),Reflect.get(i(e+8),n(e+16)))},"syscall/js.valueSetIndex":e=>{e>>>=0,Reflect.set(i(e+8),n(e+16),i(e+24))},"syscall/js.valueCall":e=>{e>>>=0;try{const n=i(e+8),t=Reflect.get(n,c(e+16)),s=a(e+32),r=Reflect.apply(t,n,s);e=this._inst.exports.getsp()>>>0,o(e+56,r),this.mem.setUint8(e+64,1)}catch(n){e=this._inst.exports.getsp()>>>0,o(e+56,n),this.mem.setUint8(e+64,0)}},"syscall/js.valueInvoke":e=>{e>>>=0;try{const n=i(e+8),t=a(e+16),s=Reflect.apply(n,void 0,t);e=this._inst.exports.getsp()>>>0,o(e+40,s),this.mem.setUint8(e+48,1)}catch(n){e=this._inst.exports.getsp()>>>0,o(e+40,n),this.mem.setUint8(e+48,0)}},"syscall/js.valueNew":e=>{e>>>=0;try{const n=i(e+8),t=a(e+16),s=Reflect.construct(n,t);e=this._inst.exports.getsp()>>>0,o(e+40,s),this.mem.setUint8(e+48,1)}catch(n){e=this._inst.exports.getsp()>>>0,o(e+40,n),this.mem.setUint8(e+48,0)}},"syscall/js.valueLength":n=>{e(16+(n>>>=0),parseInt(i(n+8).length))},"syscall/js.valuePrepareString":n=>{n>>>=0;const s=t.encode(String(i(n+8)));o(n+16,s),e(n+24,s.length)},"syscall/js.valueLoadString":e=>{const n=i(8+(e>>>=0));l(e+16).set(n)},"syscall/js.valueInstanceOf":e=>{e>>>=0,this.mem.setUint8(e+24,i(e+8)instanceof i(e+16)?1:0)},"syscall/js.copyBytesToGo":n=>{const t=l(8+(n>>>=0)),s=i(n+32);if(!(s instanceof Uint8Array||s instanceof Uint8ClampedArray))return void this.mem.setUint8(n+48,0);const r=s.subarray(0,t.length);t.set(r),e(n+40,r.length),this.mem.setUint8(n+48,1)},"syscall/js.copyBytesToJS":n=>{const t=i(8+(n>>>=0)),s=l(n+16);if(!(t instanceof Uint8Array||t instanceof Uint8ClampedArray))return void this.mem.setUint8(n+48,0);const r=s.subarray(0,t.length);t.set(r),e(n+40,r.length),this.mem.setUint8(n+48,1)},debug:e=>{console.log(e)}}}}run(e){return n(this,null,(function*(){if(!(e instanceof WebAssembly.Instance))throw new Error("Go.run: WebAssembly.Instance expected");this._inst=e,this.mem=new DataView(this._inst.exports.mem.buffer),this._values=[NaN,0,null,!0,!1,s,this],this._goRefCounts=new Array(this._values.length).fill(1/0),this._ids=new Map([[0,1],[null,2],[!0,3],[!1,4],[s,5],[this,6]]),this._idPool=[],this.exited=!1;let n=4096;const r=e=>{const s=n,r=t.encode(e+"\0");return new Uint8Array(this.mem.buffer,n,r.length).set(r),n+=r.length,n%8!=0&&(n+=8-n%8),s},i=this.argv.length,o=[];this.argv.forEach((e=>{o.push(r(e))})),o.push(0),Object.keys(this.env).sort().forEach((e=>{o.push(r(`${e}=${this.env[e]}`))})),o.push(0);const l=n;if(o.forEach((e=>{this.mem.setUint32(n,e,!0),this.mem.setUint32(n+4,0,!0),n+=8})),n>=12288)throw new Error("total length of command line and environment variables exceeds limit");this._inst.exports.run(i,l),this.exited&&this._resolveExitPromise(),yield this._exitPromise}))}_resume(){if(this.exited)throw new Error("Go program has already exited");this._inst.exports.resume(),this.exited&&this._resolveExitPromise()}_makeFuncWrapper(e){const n=this;return function(){const t={id:e,this:this,args:arguments};return n._pendingEvent=t,n._resume(),t.result}}}})(),t=({data:r})=>{let i=new TextDecoder,o=s.fs,l="";o.writeSync=(n,t)=>{if(1===n)e(t);else{if(2!==n)throw new Error("Bad write");{l+=i.decode(t);let e=l.split("\n");e.length>1&&console.log(e.slice(0,-1).join("\n")),l=e[e.length-1]}}return t.length};let a,c=[],u=0;t=({data:e})=>(e.length>0&&(c.push(e),a&&a()),f),o.read=(e,n,t,s,r,i)=>{if(0!==e||0!==t||s!==n.length||null!==r)throw new Error("Bad read");if(0===c.length)return void(a=()=>o.read(e,n,t,s,r,i));let l=c[0],f=Math.max(0,Math.min(s,l.length-u));n.set(l.subarray(u,u+f),t),u+=f,u===l.length&&(c.shift(),u=0),i(null,f)};let f=new s.Go;return f.argv=["","--service=0.21.3"],function(e,t){return n(this,null,(function*(){if(e instanceof WebAssembly.Module)return WebAssembly.instantiate(e,t.importObject);const n=yield fetch(e);if(!n.ok)throw new Error(`Failed to download ${JSON.stringify(e)}`);if("instantiateStreaming"in WebAssembly&&/^application\/wasm($|;)/i.test(n.headers.get("Content-Type")||""))return(yield WebAssembly.instantiateStreaming(n,t.importObject)).instance;const s=yield n.arrayBuffer();return(yield WebAssembly.instantiate(s,t.importObject)).instance}))}(r,f).then((n=>{e(null),f.run(n)}),(n=>{e(n)})),f},e=>t(e)})((e=>s.onmessage({data:e})));s={onmessage:null,postMessage:t=>setTimeout((()=>e=n({data:t}))),terminate(){if(e)for(let n of e._scheduledTimeouts.values())clearTimeout(n)}}}const f=new Promise(((e,n)=>{r=e,i=n}));s.onmessage=({data:e})=>{s.onmessage=({data:e})=>p(e),e?i(e):r()},s.postMessage(n||new URL(e,location.href).toString());let{readFromStdout:p,service:w}=function(e){const n={},t={didClose:!1,reason:""};let s={},r=0,i=0,l=new Uint8Array(16384),f=0,p=(n,i,o)=>{if(t.didClose)return o("The service is no longer running"+t.reason,null);let l=r++;s[l]=(e,t)=>{try{o(e,t)}finally{n&&n.unref()}},n&&n.ref(),e.writeToStdin(a({id:l,isRequest:!0,value:i}))},w=(n,s)=>{if(t.didClose)throw new Error("The service is no longer running"+t.reason);e.writeToStdin(a({id:n,isRequest:!1,value:s}))},b=(t,s)=>o(this,null,(function*(){try{if("ping"===s.command)return void w(t,{});if("number"==typeof s.key){const e=n[s.key];if(!e)return;const r=e[s.command];if(r)return void(yield r(t,s))}throw new Error("Invalid command: "+s.command)}catch(n){const s=[G(n,e,null,void 0,"")];try{w(t,{errors:s})}catch(e){}}})),k=!0,S=e=>{if(k){k=!1;let n=String.fromCharCode(...e);if("0.21.3"!==n)throw new Error(`Cannot start service: Host version "0.21.3" does not match binary version ${m(n)}`);return}let n=function(e){let n=()=>{switch(t.read8()){case 0:return null;case 1:return!!t.read8();case 2:return t.read32();case 3:return u(t.read());case 4:return t.read();case 5:{let e=t.read32(),s=[];for(let t=0;t<e;t++)s.push(n());return s}case 6:{let e=t.read32(),s={};for(let r=0;r<e;r++)s[u(t.read())]=n();return s}default:throw new Error("Invalid packet")}},t=new d(e),s=t.read32(),r=0==(1&s);s>>>=1;let i=n();if(t.ptr!==e.length)throw new Error("Invalid packet");return{id:s,isRequest:r,value:i}}(e);if(n.isRequest)b(n.id,n.value);else{let e=s[n.id];delete s[n.id],n.value.error?e(n.value.error,{}):e(null,n.value)}};return{readFromStdout:e=>{let n=f+e.length;if(n>l.length){let e=new Uint8Array(2*n);e.set(l),l=e}l.set(e,f),f+=e.length;let t=0;for(;t+4<=f;){let e=h(l,t);if(t+4+e>f)break;t+=4,S(l.subarray(t,t+e)),t+=e}t>0&&(l.copyWithin(0,t,f),f-=t)},afterClose:e=>{t.didClose=!0,e&&(t.reason=": "+(e.message||e));const n="The service was stopped"+t.reason;for(let e in s)s[e](n,null);s={}},service:{buildOrContext:({callName:t,refs:s,options:r,isTTY:o,defaultWD:l,callback:a})=>{let f=0;const d=i++,h={},m={ref(){1==++f&&s&&s.ref()},unref(){0==--f&&(delete n[d],s&&s.unref())}};n[d]=h,m.ref(),function(e,n,t,s,r,i,o,l,a,f,d){const h=L(),p="context"===e,m=(e,n)=>{const s=[];try{M(s,l,{},a,g)}catch(e){}const o=G(e,i,h,void 0,n);t(r,{command:"error",flags:s,error:o},(()=>{o.detail=h.load(o.detail),d(z(p?"Context failed":"Build failed",[o],[]),null)}))};let y;if("object"==typeof l){const e=l.plugins;if(void 0!==e){if(!Array.isArray(e))return m(new Error('"plugins" must be an array'),"");y=e}}if(y&&y.length>0)return i.isSync?m(new Error("Cannot use plugins in synchronous API calls"),""):void W(n,t,s,r,i,o,l,y,h).then((e=>{if(!e.ok)return m(e.error,e.pluginName);try{w(e.requestPlugins,e.runOnEndCallbacks,e.scheduleOnDisposeCallbacks)}catch(e){m(e,"")}}),(e=>m(e,"")));try{w(null,((e,n)=>n([],[])),(()=>{}))}catch(e){m(e,"")}function w(m,y,w){const b=i.hasFS,{entries:k,flags:S,write:P,stdinContents:C,stdinResolveDir:I,absWorkingDir:R,nodePaths:W,mangleCache:L}=function(e,n,t,s,r){var i;let o=[],l=[],a=Object.create(null),u=null,f=null;M(o,n,a,t,s),V(o,n,a);let d=A(n,a,"sourcemap",O),h=A(n,a,"bundle",v),p=A(n,a,"splitting",v),m=A(n,a,"preserveSymlinks",v),g=A(n,a,"metafile",v),y=A(n,a,"outfile",x),w=A(n,a,"outdir",x),b=A(n,a,"outbase",x),k=A(n,a,"tsconfig",x),_=A(n,a,"resolveExtensions",T),E=A(n,a,"nodePaths",T),S=A(n,a,"mainFields",T),P=A(n,a,"conditions",T),C=A(n,a,"external",T),I=A(n,a,"packages",x),R=A(n,a,"alias",$),W=A(n,a,"loader",$),L=A(n,a,"outExtension",$),B=A(n,a,"publicPath",x),G=A(n,a,"entryNames",x),q=A(n,a,"chunkNames",x),z=A(n,a,"assetNames",x),Y=A(n,a,"inject",T),J=A(n,a,"banner",$),H=A(n,a,"footer",$),X=A(n,a,"entryPoints",j),Q=A(n,a,"absWorkingDir",x),K=A(n,a,"stdin",$),Z=null!=(i=A(n,a,"write",v))?i:r,ee=A(n,a,"allowOverwrite",v),ne=A(n,a,"mangleCache",$);if(a.plugins=!0,D(n,a,`in ${e}() call`),d&&o.push("--sourcemap"+(!0===d?"":`=${d}`)),h&&o.push("--bundle"),ee&&o.push("--allow-overwrite"),p&&o.push("--splitting"),m&&o.push("--preserve-symlinks"),g&&o.push("--metafile"),y&&o.push(`--outfile=${y}`),w&&o.push(`--outdir=${w}`),b&&o.push(`--outbase=${b}`),k&&o.push(`--tsconfig=${k}`),I&&o.push(`--packages=${I}`),_){let e=[];for(let n of _){if(F(n,"resolve extension"),n.indexOf(",")>=0)throw new Error(`Invalid resolve extension: ${n}`);e.push(n)}o.push(`--resolve-extensions=${e.join(",")}`)}if(B&&o.push(`--public-path=${B}`),G&&o.push(`--entry-names=${G}`),q&&o.push(`--chunk-names=${q}`),z&&o.push(`--asset-names=${z}`),S){let e=[];for(let n of S){if(F(n,"main field"),n.indexOf(",")>=0)throw new Error(`Invalid main field: ${n}`);e.push(n)}o.push(`--main-fields=${e.join(",")}`)}if(P){let e=[];for(let n of P){if(F(n,"condition"),n.indexOf(",")>=0)throw new Error(`Invalid condition: ${n}`);e.push(n)}o.push(`--conditions=${e.join(",")}`)}if(C)for(let e of C)o.push(`--external:${F(e,"external")}`);if(R)for(let e in R){if(e.indexOf("=")>=0)throw new Error(`Invalid package name in alias: ${e}`);o.push(`--alias:${e}=${F(R[e],"alias",e)}`)}if(J)for(let e in J){if(e.indexOf("=")>=0)throw new Error(`Invalid banner file type: ${e}`);o.push(`--banner:${e}=${F(J[e],"banner",e)}`)}if(H)for(let e in H){if(e.indexOf("=")>=0)throw new Error(`Invalid footer file type: ${e}`);o.push(`--footer:${e}=${F(H[e],"footer",e)}`)}if(Y)for(let e of Y)o.push(`--inject:${F(e,"inject")}`);if(W)for(let e in W){if(e.indexOf("=")>=0)throw new Error(`Invalid loader extension: ${e}`);o.push(`--loader:${e}=${F(W[e],"loader",e)}`)}if(L)for(let e in L){if(e.indexOf("=")>=0)throw new Error(`Invalid out extension: ${e}`);o.push(`--out-extension:${e}=${F(L[e],"out extension",e)}`)}if(X)if(Array.isArray(X))for(let e=0,n=X.length;e<n;e++){let n=X[e];if("object"==typeof n&&null!==n){let t=Object.create(null),s=A(n,t,"in",x),r=A(n,t,"out",x);if(D(n,t,"in entry point at index "+e),void 0===s)throw new Error('Missing property "in" for entry point at index '+e);if(void 0===r)throw new Error('Missing property "out" for entry point at index '+e);l.push([r,s])}else l.push(["",F(n,"entry point at index "+e)])}else for(let e in X)l.push([e,F(X[e],"entry point",e)]);if(K){let e=Object.create(null),n=A(K,e,"contents",U),t=A(K,e,"resolveDir",x),s=A(K,e,"sourcefile",x),r=A(K,e,"loader",x);D(K,e,'in "stdin" object'),s&&o.push(`--sourcefile=${s}`),r&&o.push(`--loader=${r}`),t&&(f=t),"string"==typeof n?u=c(n):n instanceof Uint8Array&&(u=n)}let te=[];if(E)for(let e of E)e+="",te.push(e);return{entries:l,flags:o,write:Z,stdinContents:u,stdinResolveDir:f,absWorkingDir:Q,nodePaths:te,mangleCache:N(ne)}}(e,l,a,g,b);if(P&&!i.hasFS)throw new Error('The "write" option is unavailable in this environment');const B={command:"build",key:n,entries:k,flags:S,write:P,stdinContents:C,stdinResolveDir:I,absWorkingDir:R||f,nodePaths:W,context:p};m&&(B.plugins=m),L&&(B.mangleCache=L);const G=(e,n)=>{const t={errors:Y(e.errors,h),warnings:Y(e.warnings,h),outputFiles:void 0,metafile:void 0,mangleCache:void 0},s=t.errors.slice(),r=t.warnings.slice();e.outputFiles&&(t.outputFiles=e.outputFiles.map(Q)),e.metafile&&(t.metafile=JSON.parse(e.metafile)),e.mangleCache&&(t.mangleCache=e.mangleCache),void 0!==e.writeToStdout&&console.log(u(e.writeToStdout).replace(/\n$/,"")),y(t,((e,i)=>{if(s.length>0||e.length>0){const t=z("Build failed",s.concat(e),r.concat(i));return n(t,null,e,i)}n(null,t,e,i)}))};let q,J;p&&(o["on-end"]=(e,n)=>new Promise((t=>{G(n,((n,r,i,o)=>{const l={errors:i,warnings:o};J&&J(n,r),q=void 0,J=void 0,s(e,l),t()}))}))),t(r,B,((e,l)=>{if(e)return d(new Error(e),null);if(!p)return G(l,((e,n)=>(w(),d(e,n))));if(l.errors.length>0)return d(z("Context failed",l.errors,l.warnings),null);let a=!1;const c={rebuild:()=>(q||(q=new Promise(((e,s)=>{let i;J=(n,t)=>{i||(i=()=>n?s(n):e(t))};const o=()=>{t(r,{command:"rebuild",key:n},((e,n)=>{e?s(new Error(e)):i?i():o()}))};o()}))),q),watch:(e={})=>new Promise(((s,o)=>{if(!i.hasFS)throw new Error('Cannot use the "watch" API in this environment');D(e,{},"in watch() call"),t(r,{command:"watch",key:n},(e=>{e?o(new Error(e)):s(void 0)}))})),serve:(e={})=>new Promise(((l,a)=>{if(!i.hasFS)throw new Error('Cannot use the "serve" API in this environment');const c={},u=A(e,c,"port",_),f=A(e,c,"host",x),d=A(e,c,"servedir",x),h=A(e,c,"keyfile",x),p=A(e,c,"certfile",x),m=A(e,c,"fallback",x),g=A(e,c,"onRequest",E);D(e,c,"in serve() call");const y={command:"serve",key:n,onRequest:!!g};void 0!==u&&(y.port=u),void 0!==f&&(y.host=f),void 0!==d&&(y.servedir=d),void 0!==h&&(y.keyfile=h),void 0!==p&&(y.certfile=p),void 0!==m&&(y.fallback=m),t(r,y,((e,n)=>{if(e)return a(new Error(e));g&&(o["serve-request"]=(e,n)=>{g(n.args),s(e,{})}),l(n)}))})),cancel:()=>new Promise((e=>{if(a)return e();t(r,{command:"cancel",key:n},(()=>{e()}))})),dispose:()=>new Promise((e=>{if(a)return e();a=!0,t(r,{command:"dispose",key:n},(()=>{e(),w(),r.unref()}))}))};r.ref(),d(null,c)}))}}(t,d,p,w,m,e,h,r,o,l,((e,n)=>{try{a(e,n)}finally{m.unref()}}))},transform:({callName:n,refs:t,input:s,options:r,isTTY:i,fs:o,callback:l})=>{const a=L();let u=u=>{try{if("string"!=typeof s&&!(s instanceof Uint8Array))throw new Error('The input to "transform" must be a string or a Uint8Array');let{flags:e,mangleCache:f}=function(e,n,t,s){let r=[],i=Object.create(null);M(r,n,i,t,s),V(r,n,i);let o=A(n,i,"sourcemap",O),l=A(n,i,"sourcefile",x),a=A(n,i,"loader",x),c=A(n,i,"banner",x),u=A(n,i,"footer",x),f=A(n,i,"mangleCache",$);return D(n,i,`in ${e}() call`),o&&r.push(`--sourcemap=${!0===o?"external":o}`),l&&r.push(`--sourcefile=${l}`),a&&r.push(`--loader=${a}`),c&&r.push(`--banner=${c}`),u&&r.push(`--footer=${u}`),{flags:r,mangleCache:N(f)}}(n,r,i,y),d={command:"transform",flags:e,inputFS:null!==u,input:null!==u?c(u):"string"==typeof s?c(s):s};f&&(d.mangleCache=f),p(t,d,((e,n)=>{if(e)return l(new Error(e),null);let t=Y(n.errors,a),s=Y(n.warnings,a),r=1,i=()=>{if(0==--r){let e={warnings:s,code:n.code,map:n.map,mangleCache:void 0,legalComments:void 0};"legalComments"in n&&(e.legalComments=null==n?void 0:n.legalComments),n.mangleCache&&(e.mangleCache=null==n?void 0:n.mangleCache),l(null,e)}};if(t.length>0)return l(z("Transform failed",t,s),null);n.codeFS&&(r++,o.readFile(n.code,((e,t)=>{null!==e?l(e,null):(n.code=t,i())}))),n.mapFS&&(r++,o.readFile(n.map,((e,t)=>{null!==e?l(e,null):(n.map=t,i())}))),i()}))}catch(n){let s=[];try{M(s,r,{},i,y)}catch(e){}const o=G(n,e,a,void 0,"");p(t,{command:"error",flags:s,error:o},(()=>{o.detail=a.load(o.detail),l(z("Transform failed",[o],[]),null)}))}};if(("string"==typeof s||s instanceof Uint8Array)&&s.length>1048576){let e=u;u=()=>o.writeFile(s,e)}u(null)},formatMessages:({callName:e,refs:n,messages:t,options:s,callback:r})=>{if(!s)throw new Error(`Missing second argument in ${e}() call`);let i={},o=A(s,i,"kind",x),l=A(s,i,"color",v),a=A(s,i,"terminalWidth",_);if(D(s,i,`in ${e}() call`),void 0===o)throw new Error(`Missing "kind" in ${e}() call`);if("error"!==o&&"warning"!==o)throw new Error(`Expected "kind" to be "error" or "warning" in ${e}() call`);let c={command:"format-msgs",messages:H(t,"messages",null,"",a),isWarning:"warning"===o};void 0!==l&&(c.color=l),void 0!==a&&(c.terminalWidth=a),p(n,c,((e,n)=>{if(e)return r(new Error(e),null);r(null,n.messages)}))},analyzeMetafile:({callName:e,refs:n,metafile:t,options:s,callback:r})=>{void 0===s&&(s={});let i={},o=A(s,i,"color",v),l=A(s,i,"verbose",v);D(s,i,`in ${e}() call`);let a={command:"analyze-metafile",metafile:t};void 0!==o&&(a.color=o),void 0!==l&&(a.verbose=l),p(n,a,((e,n)=>{if(e)return r(new Error(e),null);r(null,n.result)}))}}}}({writeToStdin(e){s.postMessage(e)},isSync:!1,hasFS:!1,esbuild:l});yield f,Z=()=>{s.terminate(),K=void 0,Z=void 0,ee=void 0},ee={build:e=>new Promise(((n,t)=>w.buildOrContext({callName:"build",refs:null,options:e,isTTY:!1,defaultWD:"/",callback:(e,s)=>e?t(e):n(s)}))),context:e=>new Promise(((n,t)=>w.buildOrContext({callName:"context",refs:null,options:e,isTTY:!1,defaultWD:"/",callback:(e,s)=>e?t(e):n(s)}))),transform:(e,n)=>new Promise(((t,s)=>w.transform({callName:"transform",refs:null,input:e,options:n||{},isTTY:!1,fs:{readFile(e,n){n(new Error("Internal error"),null)},writeFile(e,n){n(null)}},callback:(e,n)=>e?s(e):t(n)}))),formatMessages:(e,n)=>new Promise(((t,s)=>w.formatMessages({callName:"formatMessages",refs:null,messages:e,options:n,callback:(e,n)=>e?s(e):t(n)}))),analyzeMetafile:(e,n)=>new Promise(((t,s)=>w.analyzeMetafile({callName:"analyzeMetafile",refs:null,metafile:"string"==typeof e?e:JSON.stringify(e),options:n,callback:(e,n)=>e?s(e):t(n)})))}})),me=l})(e=t.nmd(e))}}]);